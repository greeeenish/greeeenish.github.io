<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="什么时候接触前端？对前端的理解？实验室的项目介绍为什么选择vue？用过react吗？vue双向绑定原理 Object.defineProperty(vue2) / Proxy(vue3)  为对象的属性来设定getter和setter,从而我们可以劫持用户对对象属性的取值和赋值  1234567891011121314151617const obj = &amp;#123;&amp;#125;;let val =">
<meta property="og:type" content="article">
<meta property="og:title" content="腾讯实习面试总结（二）">
<meta property="og:url" content="http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/index.html">
<meta property="og:site_name" content="Greenish">
<meta property="og:description" content="什么时候接触前端？对前端的理解？实验室的项目介绍为什么选择vue？用过react吗？vue双向绑定原理 Object.defineProperty(vue2) / Proxy(vue3)  为对象的属性来设定getter和setter,从而我们可以劫持用户对对象属性的取值和赋值  1234567891011121314151617const obj = &amp;#123;&amp;#125;;let val =">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/img/vue-data-bind.png">
<meta property="og:image" content="http://yoursite.com/img/prototype.jpg">
<meta property="og:updated_time" content="2019-03-27T09:15:05.046Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="腾讯实习面试总结（二）">
<meta name="twitter:description" content="什么时候接触前端？对前端的理解？实验室的项目介绍为什么选择vue？用过react吗？vue双向绑定原理 Object.defineProperty(vue2) / Proxy(vue3)  为对象的属性来设定getter和setter,从而我们可以劫持用户对对象属性的取值和赋值  1234567891011121314151617const obj = &amp;#123;&amp;#125;;let val =">
<meta name="twitter:image" content="http://yoursite.com/img/vue-data-bind.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>腾讯实习面试总结（二）</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/03/07/腾讯实习面试总结（一）/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&text=腾讯实习面试总结（二）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&is_video=false&description=腾讯实习面试总结（二）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=腾讯实习面试总结（二）&body=Check out this article: http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&name=腾讯实习面试总结（二）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候接触前端？对前端的理解？"><span class="toc-number">1.</span> <span class="toc-text">什么时候接触前端？对前端的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验室的项目介绍"><span class="toc-number">2.</span> <span class="toc-text">实验室的项目介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么选择vue？用过react吗？"><span class="toc-number">3.</span> <span class="toc-text">为什么选择vue？用过react吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue双向绑定原理"><span class="toc-number">4.</span> <span class="toc-text">vue双向绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iview看过源码吗？自己写过组件吗？"><span class="toc-number">5.</span> <span class="toc-text">iview看过源码吗？自己写过组件吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iview使用vue组件的定义"><span class="toc-number">5.0.1.</span> <span class="toc-text">iview使用vue组件的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue组件的重要概念"><span class="toc-number">5.0.2.</span> <span class="toc-text">vue组件的重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单文件组件"><span class="toc-number">5.0.3.</span> <span class="toc-text">单文件组件</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#webstorage和cookie的区别？"><span class="toc-number">6.</span> <span class="toc-text">webstorage和cookie的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webstorage"><span class="toc-number">6.0.1.</span> <span class="toc-text">webstorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">6.0.2.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相同和区别"><span class="toc-number">6.0.3.</span> <span class="toc-text">相同和区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解ES6的哪些新特性？"><span class="toc-number">7.</span> <span class="toc-text">了解ES6的哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6的模块化？"><span class="toc-number">8.</span> <span class="toc-text">ES6的模块化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise？"><span class="toc-number">9.</span> <span class="toc-text">promise？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js怎么实现链式调用？"><span class="toc-number">10.</span> <span class="toc-text">js怎么实现链式调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js怎么创建对象？"><span class="toc-number">11.</span> <span class="toc-text">js怎么创建对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工厂模式"><span class="toc-number">11.1.</span> <span class="toc-text">1.工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数模式"><span class="toc-number">11.2.</span> <span class="toc-text">2.构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-原型模式"><span class="toc-number">11.3.</span> <span class="toc-text">3.原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-组合使用构造函数模式和原型模式"><span class="toc-number">11.4.</span> <span class="toc-text">4.组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-动态原型模式"><span class="toc-number">11.5.</span> <span class="toc-text">5.动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生构造函数模式"><span class="toc-number">11.6.</span> <span class="toc-text">6.寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-稳妥构造函数模式"><span class="toc-number">11.7.</span> <span class="toc-text">7.稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从URL输入到页面显示经历了什么？"><span class="toc-number">12.</span> <span class="toc-text">从URL输入到页面显示经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上面的步骤可以从哪些地方优化？"><span class="toc-number">13.</span> <span class="toc-text">上面的步骤可以从哪些地方优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DNS解析"><span class="toc-number">13.0.1.</span> <span class="toc-text">1.DNS解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP连接"><span class="toc-number">13.0.2.</span> <span class="toc-text">2.TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HTTP请求"><span class="toc-number">13.0.3.</span> <span class="toc-text">3.HTTP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-服务器处理请求，返回HTTP报文"><span class="toc-number">13.0.4.</span> <span class="toc-text">4.服务器处理请求，返回HTTP报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-浏览器解析渲染"><span class="toc-number">13.0.5.</span> <span class="toc-text">5.浏览器解析渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP有什么了解？为什么是可靠的？"><span class="toc-number">14.</span> <span class="toc-text">TCP有什么了解？为什么是可靠的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#讲一下HTTP的头部"><span class="toc-number">15.</span> <span class="toc-text">讲一下HTTP的头部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用标准请求头部"><span class="toc-number">15.0.1.</span> <span class="toc-text">常用标准请求头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用非标准请求头字段"><span class="toc-number">15.0.2.</span> <span class="toc-text">常用非标准请求头字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用标准响应头部"><span class="toc-number">15.0.3.</span> <span class="toc-text">常用标准响应头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用非标准请求头字段-1"><span class="toc-number">15.0.4.</span> <span class="toc-text">常用非标准请求头字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST和GET的区别"><span class="toc-number">16.</span> <span class="toc-text">POST和GET的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？"><span class="toc-number">17.</span> <span class="toc-text">深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搜索引擎优化？"><span class="toc-number">18.</span> <span class="toc-text">搜索引擎优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是语义化？语义化的好处？"><span class="toc-number">19.</span> <span class="toc-text">什么是语义化？语义化的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5的新特性？"><span class="toc-number">20.</span> <span class="toc-text">HTML5的新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见web安全和防御？"><span class="toc-number">21.</span> <span class="toc-text">常见web安全和防御？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git和svn的区别？各自的应用场景？"><span class="toc-number">22.</span> <span class="toc-text">git和svn的区别？各自的应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写过微信小程序吗？为什么小程序的性能比较好？"><span class="toc-number">23.</span> <span class="toc-text">写过微信小程序吗？为什么小程序的性能比较好？</span></a></li>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        腾讯实习面试总结（二）
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">Greenish</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-03-17T13:39:45.000Z" itemprop="datePublished">2019-03-17</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="什么时候接触前端？对前端的理解？"><a href="#什么时候接触前端？对前端的理解？" class="headerlink" title="什么时候接触前端？对前端的理解？"></a>什么时候接触前端？对前端的理解？</h2><h2 id="实验室的项目介绍"><a href="#实验室的项目介绍" class="headerlink" title="实验室的项目介绍"></a>实验室的项目介绍</h2><h2 id="为什么选择vue？用过react吗？"><a href="#为什么选择vue？用过react吗？" class="headerlink" title="为什么选择vue？用过react吗？"></a>为什么选择vue？用过react吗？</h2><h2 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h2><ul>
<li><p>Object.defineProperty(vue2) / Proxy(vue3)</p>
<ul>
<li>为对象的属性来设定getter和setter,从而我们可以劫持用户对对象属性的取值和赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">let val = <span class="string">'cjg'</span>;</span><br><span class="line">Object.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    console.log(<span class="string">'劫持了你的取值操作啦'</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;,</span><br><span class="line">  set(newVal) &#123;</span><br><span class="line">    console.log(<span class="string">'劫持了你的赋值操作啦'</span>);</span><br><span class="line">    val = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(obj.name);</span><br><span class="line">obj.name = <span class="string">'cwc'</span>;</span><br><span class="line">console.log(obj.name);</span><br></pre></td></tr></table></figure>
</li>
<li><p>观察者模式（发布订阅模式）</p>
<ul>
<li>多个订阅者可以向同一发布者订阅一个事件，当事件发生的时候，发布者通知所有订阅该事件的订阅者</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加订阅者</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subs.indexOf(sub) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知订阅者</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sub1 update'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub1 = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sub2 update'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dep.addSub(sub);</span><br><span class="line">dep.addSub(sub1);</span><br><span class="line">dep.notify(); <span class="comment">// 通知订阅者事件发生，触发他们的更新函数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Vue官方文档的解释：</p>
<blockquote>
<p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <strong>Object.defineProperty</strong>把这些属性全部转为 <strong>getter/setter</strong>。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>每个组件实例都有相应的 <strong>watcher</strong> 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p>
</blockquote>
<p><img src="/img/vue-data-bind.png" alt="Vue双向数据绑定"></p>
<ol>
<li>通过<strong>Object.defineProperty</strong>定义data对象属性的get和set方法，对需要监听的数据进行getter和setter进行劫持，当属性被赋值/取值时，Vue.js就可以察觉到并作出相应的处理</li>
<li>通过<strong>订阅发布模式</strong>可以为对象的每个属性都创建一个发布者，当有其他订阅者依赖于这个属性时，将订阅者加入到发布者的队列中。利用Object.defineProperty的数据劫持，在属性的setter调用的时候，该属性的发布者通知所有订阅者更新内容。</li>
</ol>
<ul>
<li><code>Observer</code>: 数据的观察者，让数据对象的读写操作都处于自己的监管之下</li>
<li><code>Watcher</code>: 数据的订阅者，数据的变化会通知到Watcher，然后由Watcher进行相应的操作，例如更新视图</li>
<li><code>Dep</code>:数据的发布者， Observer与Watcher的纽带。 有一个subs 数组用来保存和这个依赖有关的 Watcher。当数据变化时，会被Observer观察到，然后由Dep通知到Watcher</li>
</ul>
<h2 id="iview看过源码吗？自己写过组件吗？"><a href="#iview看过源码吗？自己写过组件吗？" class="headerlink" title="iview看过源码吗？自己写过组件吗？"></a>iview看过源码吗？自己写过组件吗？</h2><h4 id="iview使用vue组件的定义"><a href="#iview使用vue组件的定义" class="headerlink" title="iview使用vue组件的定义"></a>iview使用vue组件的定义</h4><ul>
<li>组件是可复用的 Vue 实例</li>
<li>一个组件的 data 选项必须是一个函数。因此每个实例可以维护一份被返回对象的独立的拷贝，如果不是这样，一个实例上面数据的变化就会影响到其他所有的实例</li>
<li>每个组件必须只有一个根元素。可以将模板的内容包裹在一个父元素内，来修复这个问题</li>
</ul>
<h4 id="vue组件的重要概念"><a href="#vue组件的重要概念" class="headerlink" title="vue组件的重要概念"></a>vue组件的重要概念</h4><ul>
<li>props：通过props向子组件传递数据</li>
<li>$emit：自定义事件的系统来监听子组件事件<ul>
<li>父组件通过v-on监听子组件实例的任意事件</li>
<li>子组件可以通过调用内建的$emit()方法触发事件，第一个参数是这一组参数的名称，后面的是参数值</li>
<li>自定义事件也可以用于创建支持 v-model的自定义输入组件</li>
</ul>
</li>
<li>slot：通过插槽分发内容</li>
</ul>
<h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h4><ul>
<li>使用Vue.component定义全局组件的缺点：<ul>
<li><strong>全局定义 </strong> 强制要求每个 component 中的命名不得重复</li>
<li><strong>字符串模板 </strong> 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 <code>\</code></li>
<li><strong>不支持 CSS </strong> 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li>
<li><strong>没有构建步骤 </strong> 限制只能使用 HTML 和 ES5 JavaScript, 而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li>
</ul>
</li>
<li>单文件组件：使用扩展名为.vue的文件<ul>
<li>完整语法高亮</li>
<li>CommonJS 模块</li>
<li>组件作用域的 CSS</li>
</ul>
</li>
<li>关注点分离不等于文件分离<ul>
<li>松散耦合的组件</li>
<li>在一个组件里，其模板、逻辑和样式是内部耦合的，并且把他们搭配在一起实际上使得组件更加内聚且更可维护</li>
</ul>
</li>
</ul>
<h2 id="webstorage和cookie的区别？"><a href="#webstorage和cookie的区别？" class="headerlink" title="webstorage和cookie的区别？"></a>webstorage和cookie的区别？</h2><h4 id="webstorage"><a href="#webstorage" class="headerlink" title="webstorage"></a>webstorage</h4><ul>
<li><p><strong>localStorage：</strong>localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p>
</li>
<li><p><strong>sessionStorage：</strong>sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。</p>
</li>
<li><p>使用相同的API</p>
<ul>
<li>setItem</li>
<li>getItem</li>
<li>removeItem</li>
<li>clear</li>
</ul>
</li>
<li><p>作用域不同</p>
<p>不同浏览器无法共享localStorage或sessionStorage中的信息。</p>
<p>相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p>
</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><ul>
<li><p>生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。但Cookie需要程序员自己封装，源生的Cookie接口不友好</p>
</li>
<li><p>使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建/修改 expires现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/"</span>;</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.cookie;</span><br><span class="line"><span class="comment">//删除cookie：只需要设置 expires 参数为以前的时间即可</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：具有极高的扩展性和可用性</p>
</li>
<li>缺点：<ul>
<li>cookie的长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。否则会被截掉</li>
<li>安全性问题。如果cookie被人拦掉了，那个人就可以获取到所有session信息。加密的话也不起什么作用</li>
<li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务端保存一个计数器。若计数器保存在客户端，则起不到什么作用</li>
</ul>
</li>
<li>安全<ul>
<li>通过良好的编程，控制保存在cookie中的session对象的大小</li>
<li>通过加密和安全传输技术，减少cookie被破解的可能性</li>
<li>只有在cookie中存放不敏感的数据，即使被盗取也不会有很大的损失</li>
<li>控制cookie的生命期，使之不会永远有效。这样的话偷盗者很可能拿到的就是一个过期的cookie</li>
</ul>
</li>
</ul>
<h4 id="相同和区别"><a href="#相同和区别" class="headerlink" title="相同和区别"></a>相同和区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>sessionStorage</th>
<th>localStorage</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据生命期 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效</td>
<td>页面会话期间可用</td>
<td>除非数据被清除，否则一直存在</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右（因为每次http请求都会携带cookie）</td>
<td>一般5M或更大</td>
<td></td>
</tr>
<tr>
<td>与服务器通信</td>
<td>由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信</td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>cookie需要自己封装setCookie，getCookie</td>
<td>可以用源生接口，也可再次封装来对Object和Array有更好的支持</td>
<td></td>
</tr>
<tr>
<td>共同点</td>
<td>都是保存在浏览器端，和服务器端的session机制不同</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="了解ES6的哪些新特性？"><a href="#了解ES6的哪些新特性？" class="headerlink" title="了解ES6的哪些新特性？"></a>了解ES6的哪些新特性？</h2><h2 id="ES6的模块化？"><a href="#ES6的模块化？" class="headerlink" title="ES6的模块化？"></a>ES6的模块化？</h2><h2 id="promise？"><a href="#promise？" class="headerlink" title="promise？"></a>promise？</h2><h2 id="js怎么实现链式调用？"><a href="#js怎么实现链式调用？" class="headerlink" title="js怎么实现链式调用？"></a>js怎么实现链式调用？</h2><p>链式调用的根本在于上一个函数的返回值有下一个要调用的方法，依次类推。</p>
<p>比较常见做法是自己写个类来封装数据，然后提供一堆处理这个数据的方法，每个（或大部分）方法都返回 <code>this</code>(return this)，这样就能链式调用了。</p>
<h2 id="js怎么创建对象？"><a href="#js怎么创建对象？" class="headerlink" title="js怎么创建对象？"></a>js怎么创建对象？</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h3><p>工厂模式抽象了创建具体对象的过程，用函数封装封装以特定接口创建对象的细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决了创建多个相似对象的问题，但没有解决<strong>对象识别的问题</strong>（即怎样知道一个对象的类型）</p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2.构造函数模式"></a>2.构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数和工厂模式的区别：<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了this对象</li>
<li>没有return语句</li>
<li>可以用instanceof操作符检测对象类型</li>
</ul>
</li>
</ul>
<ul>
<li>构造函数的问题：<ul>
<li>每个方法都要在每个实例上重新创建一遍，不同实例的同名函数是相同的</li>
</ul>
</li>
</ul>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h3><ul>
<li>原型和原型链</li>
</ul>
<p><img src="/img/prototype.jpg" alt="原型和原型链"></p>
<ol>
<li><p>构造函数Foo()</p>
<p>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</p>
</li>
<li><p>原型对象Foo.prototype</p>
<p>Foo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</p>
</li>
<li><p>实例</p>
<p>f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</p>
</li>
</ol>
<ul>
<li><p>隐式原型（__proto__）与显式原型（prototype）</p>
<ul>
<li>显式原型的作用：用来实现基于原型的继承与属性的共享</li>
<li>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着__proto__依次查找。</li>
</ul>
</li>
<li><p>用一个包含所有属性和方法的对象字面量来重写整个原型对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">'Nucholas'</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Persion.prototype, <span class="string">"constuctor"</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,		<span class="comment">//不可枚举</span></span><br><span class="line">  value: Person</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：实例中的__proto__指针仅指向原型，而不指向构造函数。重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系</p>
</li>
<li><p>原型对象的问题</p>
<ul>
<li>引用类型值属性的共享</li>
</ul>
</li>
</ul>
<h3 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4.组合使用构造函数模式和原型模式"></a>4.组合使用构造函数模式和原型模式</h3><p>创建自定义类型最常见的方式，就是组合使用构造函数模式与原型模式。</p>
<p>构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。</p>
<h3 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5.动态原型模式"></a>5.动态原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">     Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6.寄生构造函数模式"></a>6.寄生构造函数模式</h3><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一摸一样的。</p>
<p>不能依赖instanceof操作符来确定对象类型。</p>
<h3 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7.稳妥构造函数模式"></a>7.稳妥构造函数模式</h3><p>和寄生构造函数模式类似。</p>
<p>不同：创建对象的实例方法不引用this；不使用new操作符调用构造函数。</p>
<h2 id="从URL输入到页面显示经历了什么？"><a href="#从URL输入到页面显示经历了什么？" class="headerlink" title="从URL输入到页面显示经历了什么？"></a>从URL输入到页面显示经历了什么？</h2><ol>
<li>DNS解析</li>
<li>TCP连接，三次握手</li>
<li>发送HTTP请求</li>
<li>服务器处理请求，返回HTTP报文</li>
<li>浏览器解析并渲染页面<ol>
<li>处理HTML标记，构建DOM树</li>
<li>处理CSS标记，构建Style树</li>
<li>结合DOM树和Style树为渲染树</li>
<li>根据渲染树布局，计算节点的几何信息</li>
<li>绘制到屏幕（回流和重绘）</li>
</ol>
</li>
<li>断开连接，四次挥手</li>
</ol>
<h2 id="上面的步骤可以从哪些地方优化？"><a href="#上面的步骤可以从哪些地方优化？" class="headerlink" title="上面的步骤可以从哪些地方优化？"></a>上面的步骤可以从哪些地方优化？</h2><h4 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1.DNS解析"></a>1.DNS解析</h4><ul>
<li><p>DNS缓存</p>
<p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</p>
</li>
<li><p>DNS负载均衡（DNS重定向）</p>
<p>DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。</p>
<p>CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p>
</li>
</ul>
<h4 id="2-TCP连接"><a href="#2-TCP连接" class="headerlink" title="2.TCP连接"></a>2.TCP连接</h4><h4 id="3-HTTP请求"><a href="#3-HTTP请求" class="headerlink" title="3.HTTP请求"></a>3.HTTP请求</h4><ul>
<li>减少HTTP请求<ul>
<li>图片地图：多张图片合并成一张，如果每张图片都有不同的超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL。</li>
<li>合并图片</li>
<li>内联图片 data:URL </li>
<li>合并js和css</li>
</ul>
</li>
<li>HTTP缓存<ul>
<li>有效期非常长的Exprires头</li>
<li>Max-Age（替代Exprires）</li>
</ul>
</li>
</ul>
<h4 id="4-服务器处理请求，返回HTTP报文"><a href="#4-服务器处理请求，返回HTTP报文" class="headerlink" title="4.服务器处理请求，返回HTTP报文"></a>4.服务器处理请求，返回HTTP报文</h4><ul>
<li>压缩响应<ul>
<li>请求头Accept-Encoding，响应头Content-Encoding</li>
</ul>
</li>
</ul>
<h4 id="5-浏览器解析渲染"><a href="#5-浏览器解析渲染" class="headerlink" title="5.浏览器解析渲染"></a>5.浏览器解析渲染</h4><ul>
<li>减少重绘和回流，特别是回流</li>
<li>样式表放在顶部</li>
<li>js放在底部</li>
<li>js非阻塞加载<ul>
<li>异步动态加载</li>
<li>onload动态脚本</li>
<li>defer延迟脚本</li>
</ul>
</li>
</ul>
<h2 id="TCP有什么了解？为什么是可靠的？"><a href="#TCP有什么了解？为什么是可靠的？" class="headerlink" title="TCP有什么了解？为什么是可靠的？"></a>TCP有什么了解？为什么是可靠的？</h2><h2 id="讲一下HTTP的头部"><a href="#讲一下HTTP的头部" class="headerlink" title="讲一下HTTP的头部"></a>讲一下HTTP的头部</h2><p>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</p>
<h4 id="常用标准请求头部"><a href="#常用标准请求头部" class="headerlink" title="常用标准请求头部"></a>常用标准请求头部</h4><p><strong>Accept</strong>   设置接受的内容类型</p>
<blockquote>
<p>Accept: text/plain</p>
</blockquote>
<p><strong>Accept-Charset</strong>  设置接受的字符编码</p>
<blockquote>
<p>Accept-Charset: utf-8</p>
</blockquote>
<p><strong>Accept-Encoding</strong> 设置接受的编码格式</p>
<blockquote>
<p>Accept-Encoding: gzip, deflate</p>
</blockquote>
<p><strong>Accept-Datetime</strong> 设置接受的版本时间</p>
<blockquote>
<p>Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</p>
</blockquote>
<p><strong>Accept-Language</strong> 设置接受的语言</p>
<blockquote>
<p>Accept-Language: en-US</p>
</blockquote>
<p><strong>Authorization</strong>   设置HTTP身份验证的凭证</p>
<blockquote>
<p>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p>
</blockquote>
<p><strong>Cache-Control</strong>   设置请求响应链上所有的缓存机制必须遵守的指令</p>
<blockquote>
<p>Cache-Control: no-cache</p>
</blockquote>
<p><strong>Connection</strong>  设置当前连接和hop-by-hop协议请求字段列表的控制选项</p>
<blockquote>
<p>Connection: keep-alive<br>Connection: Upgrade</p>
</blockquote>
<p><strong>Content-Length</strong>  设置请求体的字节长度</p>
<blockquote>
<p>Content-Length: 348</p>
</blockquote>
<p><strong>Content-MD5</strong> 设置基于MD5算法对请求体内容进行Base64二进制编码</p>
<blockquote>
<p>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</p>
</blockquote>
<p><strong>Content-Type</strong>    设置请求体的MIME类型（适用POST和PUT请求）</p>
<blockquote>
<p>Content-Type: application/x-www-form-urlencoded</p>
</blockquote>
<p><strong>Cookie</strong>  设置服务器使用Set-Cookie发送的http cookie</p>
<blockquote>
<p>Cookie: $Version=1; Skin=new;</p>
</blockquote>
<p><strong>Date</strong>    设置消息发送的日期和时间</p>
<blockquote>
<p>Date: Tue, 15 Nov 1994 08:12:31 GMT</p>
</blockquote>
<p><strong>Expect</strong>  标识客户端需要的特殊浏览器行为</p>
<blockquote>
<p>Expect: 100-continue</p>
</blockquote>
<p><strong>Forwarded</strong>   披露客户端通过http代理连接web服务的源信息</p>
<blockquote>
<p>Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43<br>Forwarded: for=192.0.2.43, for=198.51.100.17</p>
</blockquote>
<p><strong>From</strong>    设置发送请求的用户的email地址</p>
<blockquote>
<p>From: <a href="https://link.jianshu.com?t=mailto:user@example.com" target="_blank" rel="noopener">user@example.com</a></p>
</blockquote>
<p><strong>Host</strong>    设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略</p>
<blockquote>
<p>Host: en.wikipedia.org:8080<br>Host: en.wikipedia.org</p>
</blockquote>
<p><strong>If-Match</strong>    设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源</p>
<blockquote>
<p>If-Match: “737060cd8c284d8af7ad3082f209582d</p>
</blockquote>
<p><strong>If-Modified-Since</strong>   设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified</p>
<blockquote>
<p>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</p>
</blockquote>
<p><strong>If-None-Match</strong>   设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified</p>
<blockquote>
<p>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</p>
</blockquote>
<p><strong>If-Range</strong>    设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体</p>
<blockquote>
<p>If-Range: “737060cd8c284d8af7ad3082f209582d”</p>
</blockquote>
<p><strong>If-Unmodified-Since</strong> 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应</p>
<blockquote>
<p>If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</p>
</blockquote>
<p><strong>Max-Forwards</strong>    限制代理或网关转发消息的次数</p>
<blockquote>
<p>Max-Forwards: 10</p>
</blockquote>
<p><strong>Origin</strong>  标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）</p>
<blockquote>
<p>Origin: <code>http://www.example-social-network.com</code></p>
</blockquote>
<p><strong>Pragma</strong>  设置特殊实现字段，可能会对请求响应链有多种影响</p>
<blockquote>
<p>Pragma: no-cache</p>
</blockquote>
<p><strong>Proxy-Authorization</strong> 为连接代理授权认证信息</p>
<blockquote>
<p>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</p>
</blockquote>
<p><strong>Range</strong>   请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving</p>
<blockquote>
<p>Range: bytes=500-999</p>
</blockquote>
<p><strong>Referer</strong>     设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址（轶事：这个单词正确的拼法应该是”referrer”,但是在很多规范中都拼成了”referer”，所以这个单词也就成为标准用法）</p>
<blockquote>
<p>Referer: <code>http://en.wikipedia.org/wiki/Main_Page</code></p>
</blockquote>
<p><strong>TE</strong>  设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样</p>
<blockquote>
<p>TE: trailers, deflate</p>
</blockquote>
<p><strong>Upgrade</strong> 请求服务端升级协议</p>
<blockquote>
<p>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</p>
</blockquote>
<p><strong>User-Agent</strong>  用户代理的字符串值</p>
<blockquote>
<p>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</p>
</blockquote>
<p><strong>Via</strong> 通知服务器代理请求</p>
<blockquote>
<p>Via: 1.0 fred, 1.1 example.com (Apache/1.1)</p>
</blockquote>
<p><strong>Warning</strong> 实体可能会发生的问题的通用警告</p>
<blockquote>
<p>Warning: 199 Miscellaneous warning</p>
</blockquote>
<h4 id="常用非标准请求头字段"><a href="#常用非标准请求头字段" class="headerlink" title="常用非标准请求头字段"></a>常用非标准请求头字段</h4><p><strong>X-Requested-With</strong>    标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest</p>
<blockquote>
<p>X-Requested-With: XMLHttpRequest</p>
</blockquote>
<p><strong>X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN</strong>   防止跨站请求伪造</p>
<h4 id="常用标准响应头部"><a href="#常用标准响应头部" class="headerlink" title="常用标准响应头部"></a>常用标准响应头部</h4><p><strong>Access-Control-Allow-Origin</strong> 指定哪些站点可以参与跨站资源共享</p>
<blockquote>
<p>Access-Control-Allow-Origin: *</p>
</blockquote>
<p><strong>Accept-Patch</strong>    指定服务器支持的补丁文档格式，适用于http的patch方法</p>
<blockquote>
<p>Accept-Patch: text/example;charset=utf-8</p>
</blockquote>
<p><strong>Accept-Ranges</strong>   服务器通过byte serving支持的部分内容范围类型</p>
<blockquote>
<p>Accept-Ranges: bytes</p>
</blockquote>
<p><strong>Age</strong> 对象在代理缓存中暂存的秒数</p>
<blockquote>
<p>Age: 12</p>
</blockquote>
<p><strong>Allow</strong>   设置特定资源的有效行为，适用方法不被允许的http 405错误</p>
<blockquote>
<p>Allow: GET, HEAD</p>
</blockquote>
<p><strong>Alt-Svc</strong> 服务器使用”Alt-Svc”（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取</p>
<blockquote>
<p>Alt-Svc: h2=”http2.example.com:443”; ma=7200</p>
</blockquote>
<p><strong>Cache-Control</strong>   告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒</p>
<blockquote>
<p>Cache-Control: max-age=3600</p>
</blockquote>
<p><strong>Connection</strong>  设置当前连接和hop-by-hop协议请求字段列表的控制选项</p>
<blockquote>
<p>Connection: close</p>
</blockquote>
<p><strong>Content-Disposition</strong> 告诉客户端弹出一个文件下载框，并且可以指定下载文件名</p>
<blockquote>
<p>Content-Disposition: attachment; filename=”fname.ext”</p>
</blockquote>
<p><strong>Content-Encoding</strong>    设置数据使用的编码类型</p>
<blockquote>
<p>Content-Encoding: gzip</p>
</blockquote>
<p><strong>Content-Language</strong>    为封闭内容设置自然语言或者目标用户语言</p>
<blockquote>
<p>Content-Language: en</p>
</blockquote>
<p><strong>Content-Length</strong>  响应体的字节长度</p>
<blockquote>
<p>Content-Length: 348</p>
</blockquote>
<p><strong>Content-Location</strong>    设置返回数据的另一个位置</p>
<blockquote>
<p>Content-Location: /index.htm</p>
</blockquote>
<p><strong>Content-MD5</strong> 设置基于MD5算法对响应体内容进行Base64二进制编码</p>
<blockquote>
<p>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</p>
</blockquote>
<p><strong>Content-Range</strong>   标识响应体内容属于完整消息体中的那一部分</p>
<blockquote>
<p>Content-Range: bytes 21010-47021/47022</p>
</blockquote>
<p><strong>Content-Type</strong>    设置响应体的MIME类型</p>
<blockquote>
<p>Content-Type: text/html; charset=utf-8</p>
</blockquote>
<p><strong>Date</strong>    设置消息发送的日期和时间</p>
<blockquote>
<p>Date: Tue, 15 Nov 1994 08:12:31 GMT</p>
</blockquote>
<p><strong>ETag</strong>    特定版本资源的标识符，通常是消息摘要</p>
<blockquote>
<p>ETag: “737060cd8c284d8af7ad3082f209582d”</p>
</blockquote>
<p><strong>Expires</strong> 设置响应体的过期时间</p>
<blockquote>
<p>Expires: Thu, 01 Dec 1994 16:00:00 GMT</p>
</blockquote>
<p><strong>Last-Modified</strong>   设置请求对象最后一次的修改日期</p>
<blockquote>
<p>Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</p>
</blockquote>
<p><strong>Link</strong>    设置与其他资源的类型关系</p>
<blockquote>
<p>Link: &lt;/feed&gt;; rel=”alternate”</p>
</blockquote>
<p><strong>Location</strong>    在重定向中或者创建新资源时使用</p>
<blockquote>
<p>Location: <code>http://www.w3.org/pub/WWW/People.html</code></p>
</blockquote>
<p><strong>P3P</strong> 以P3P:CP=”your_compact_policy”的格式设置支持P3P(Platform for Privacy Preferences Project)策略，大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权</p>
<blockquote>
<p>P3P: CP=”This is not a P3P policy! See <code>http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657</code> for more info.”</p>
</blockquote>
<p><strong>Pragma</strong>  设置特殊实现字段，可能会对请求响应链有多种影响</p>
<blockquote>
<p>Pragma: no-cache</p>
</blockquote>
<p><strong>Proxy-Authenticate</strong>  设置访问代理的请求权限</p>
<blockquote>
<p>Proxy-Authenticate: Basic</p>
</blockquote>
<p><strong>Public-Key-Pins</strong> 设置站点的授权TLS证书</p>
<blockquote>
<p>Public-Key-Pins: max-age=2592000; pin-sha256=”E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=”;</p>
</blockquote>
<p><strong>Refresh</strong> “重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持<br><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url=http://example.com/&quot;&gt;</code></p>
<blockquote>
<p>Refresh: 5; url=<code>http://www.w3.org/pub/WWW/People.html</code></p>
</blockquote>
<p><strong>Retry-After</strong> 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间</p>
<blockquote>
<p>Example 1: Retry-After: 120<br>Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT</p>
</blockquote>
<p><strong>Server</strong>  服务器名称</p>
<blockquote>
<p>Server: Apache/2.4.1 (Unix)</p>
</blockquote>
<p><strong>Set-Cookie</strong>  设置HTTP Cookie</p>
<blockquote>
<p>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</p>
</blockquote>
<p><strong>Status</strong>  设置HTTP响应状态</p>
<blockquote>
<p>Status: 200 OK</p>
</blockquote>
<p><strong>Strict-Transport-Security</strong>   一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域</p>
<blockquote>
<p>Strict-Transport-Security: max-age=16070400; includeSubDomains</p>
</blockquote>
<p><strong>Trailer</strong> 标识给定的header字段将展示在后续的chunked编码的消息中</p>
<blockquote>
<p>Trailer: Max-Forwards</p>
</blockquote>
<p><strong>Transfer-Encoding</strong>   设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity</p>
<blockquote>
<p>Transfer-Encoding: chunked</p>
</blockquote>
<p><strong>Upgrade</strong> 请求客户端升级协议</p>
<blockquote>
<p>Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket</p>
</blockquote>
<p><strong>Vary</strong>    通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的</p>
<blockquote>
<p>Example 1: Vary: *<br>Example 2: Vary: Accept-Language</p>
</blockquote>
<p><strong>Via</strong> 通知客户端代理，通过其要发送什么响应</p>
<blockquote>
<p>Via: 1.0 fred, 1.1 example.com (Apache/1.1)</p>
</blockquote>
<p><strong>Warning</strong> 实体可能会发生的问题的通用警告</p>
<blockquote>
<p>Warning: 199 Miscellaneous warning</p>
</blockquote>
<p><strong>WWW-Authenticate</strong>    标识访问请求实体的身份验证方案</p>
<blockquote>
<p>WWW-Authenticate: Basic</p>
</blockquote>
<p><strong>X-Frame-Options</strong> 点击劫持保护：<br>　　　deny frame中不渲染<br>　　　sameorigin 如果源不匹配不渲染<br>　　　allow-from 允许指定位置访问<br>　　　allowall 不标准，允许任意位置访问</p>
<blockquote>
<p>X-Frame-Options: deny</p>
</blockquote>
<h4 id="常用非标准请求头字段-1"><a href="#常用非标准请求头字段-1" class="headerlink" title="常用非标准请求头字段"></a>常用非标准请求头字段</h4><p><strong>X-XSS-Protection</strong>    过滤跨站脚本</p>
<blockquote>
<p>X-XSS-Protection: 1; mode=block</p>
</blockquote>
<p><strong>Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP</strong> 定义内容安全策略</p>
<blockquote>
<p>X-WebKit-CSP: default-src ‘self’</p>
</blockquote>
<h2 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h2><ul>
<li>url可见性：<ul>
<li>get，参数url可见</li>
<li>post，url参数不可见</li>
</ul>
</li>
<li>数据传输上：<ul>
<li>get，通过拼接url进行传递参数</li>
<li>post，通过body体传输参数</li>
</ul>
</li>
<li>缓存性：<ul>
<li>get请求是可以缓存的</li>
<li>post请求不可以缓存</li>
</ul>
</li>
<li>后退页面的反应<ul>
<li>get请求页面后退时，不产生影响</li>
<li>post请求页面后退时，会重新提交请求</li>
</ul>
</li>
<li>传输数据的大小<ul>
<li>get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）</li>
<li>post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</li>
</ul>
</li>
<li>效率<ul>
<li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据</li>
<li>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li>
</ul>
</li>
</ul>
<h2 id="深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？"><a href="#深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？" class="headerlink" title="深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？"></a>深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？</h2><ul>
<li>浅拷贝：引用类型的值会跟着变化</li>
<li>实现深拷贝：<ul>
<li>递归</li>
<li>JSON.stringfy和JSON.parse（存在的问题：无法拷贝到undifined、function、symbol这类数据）</li>
</ul>
</li>
</ul>
<h2 id="搜索引擎优化？"><a href="#搜索引擎优化？" class="headerlink" title="搜索引擎优化？"></a>搜索引擎优化？</h2><h2 id="什么是语义化？语义化的好处？"><a href="#什么是语义化？语义化的好处？" class="headerlink" title="什么是语义化？语义化的好处？"></a>什么是语义化？语义化的好处？</h2><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p>
<p>优点：</p>
<ul>
<li>有利于搜索</li>
<li>容易兼容不同设备</li>
<li>结构清晰，利于团队的开发、维护</li>
</ul>
<h2 id="HTML5的新特性？"><a href="#HTML5的新特性？" class="headerlink" title="HTML5的新特性？"></a>HTML5的新特性？</h2><ol>
<li>语义化标签，添加<code>&lt;header&gt;&lt;header/&gt;&lt;nav&gt;&lt;nav&gt;</code>等标签</li>
<li>增强型表单，HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。新增表单元素和表单属性</li>
<li>多媒体， 用于媒介回放的 video 和 audio 元素</li>
<li>图像效果，用于绘画的 canvas 元素，svg元素等</li>
<li>地理定位</li>
<li>拖放API</li>
<li>Web Worker。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。类似于实现多线程。</li>
<li>离线 &amp; 存储,对本地离线存储的更好的支持,local Store,Cookies等</li>
<li>WebSocket。WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。服务器推送技术。</li>
</ol>
<h2 id="常见web安全和防御？"><a href="#常见web安全和防御？" class="headerlink" title="常见web安全和防御？"></a>常见web安全和防御？</h2><p>略</p>
<h2 id="git和svn的区别？各自的应用场景？"><a href="#git和svn的区别？各自的应用场景？" class="headerlink" title="git和svn的区别？各自的应用场景？"></a>git和svn的区别？各自的应用场景？</h2><p>1）GIT是分布式的，SVN不是</p>
<p>2）GIT把内容按元数据方式存储，而SVN是按文件</p>
<p>3）GIT分支和SVN的分支不同</p>
<p>4）GIT没有一个全局的版本号，而SVN有</p>
<p>5）GIT的内容完整性要优于SVN</p>
<p>6）Git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，SVN却需要联网</p>
<h2 id="写过微信小程序吗？为什么小程序的性能比较好？"><a href="#写过微信小程序吗？为什么小程序的性能比较好？" class="headerlink" title="写过微信小程序吗？为什么小程序的性能比较好？"></a>写过微信小程序吗？为什么小程序的性能比较好？</h2><ul>
<li><p>一个WebView只对应一个用户界面。 </p>
</li>
<li><p>在打开当前页面后，小程序会提前新建一个WebView并进行初始化。 </p>
</li>
<li><p>页面跳转不再是一个WebView内部的跳转，而是上升到Native View层次上的转换。 </p>
</li>
<li><p>页面跳转时，小程序直接用初始化好的WebView进行页面展示，提高加载速度。</p>
</li>
<li><p>基础组件</p>
<p>CSS决定了界面的多样性,但由于浏览器内核的历史性和多样性，同样的一套CSS在不同平台上会带来一定程度的兼容性和性能问题。而微信小程序由于其平台的固定性，可以着力于完善基于固定平台的最优CSS样式库。用户采用基础组件开发，自然地继承了相应CSS的最优性能。 </p>
</li>
<li><p>禁用浏览器Dom API<br>开发者不支持使用标准的Dom API开发网页，最后的渲染工作由微信端的JS库进行操作。而微信小程序采用Virtual Dom，可以减少重绘和重排的次数，提高了页面的性能。如果Dom API暴露给用户，虽然界面的交互和操作上更丰富，但开发者对于Dom操作的随意性反而会降低页面的性能。<br>总之，微信小程序结合了各种优化策略。在Web层面上虚拟Dom、高性能CSS样式库，原生层面上有WebView预加载，原生模块覆盖等。虽然在开发上建立了一定的限制，但带来了整体性能上的提升。 </p>
</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候接触前端？对前端的理解？"><span class="toc-number">1.</span> <span class="toc-text">什么时候接触前端？对前端的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实验室的项目介绍"><span class="toc-number">2.</span> <span class="toc-text">实验室的项目介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么选择vue？用过react吗？"><span class="toc-number">3.</span> <span class="toc-text">为什么选择vue？用过react吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue双向绑定原理"><span class="toc-number">4.</span> <span class="toc-text">vue双向绑定原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iview看过源码吗？自己写过组件吗？"><span class="toc-number">5.</span> <span class="toc-text">iview看过源码吗？自己写过组件吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iview使用vue组件的定义"><span class="toc-number">5.0.1.</span> <span class="toc-text">iview使用vue组件的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vue组件的重要概念"><span class="toc-number">5.0.2.</span> <span class="toc-text">vue组件的重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单文件组件"><span class="toc-number">5.0.3.</span> <span class="toc-text">单文件组件</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#webstorage和cookie的区别？"><span class="toc-number">6.</span> <span class="toc-text">webstorage和cookie的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webstorage"><span class="toc-number">6.0.1.</span> <span class="toc-text">webstorage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">6.0.2.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相同和区别"><span class="toc-number">6.0.3.</span> <span class="toc-text">相同和区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#了解ES6的哪些新特性？"><span class="toc-number">7.</span> <span class="toc-text">了解ES6的哪些新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6的模块化？"><span class="toc-number">8.</span> <span class="toc-text">ES6的模块化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise？"><span class="toc-number">9.</span> <span class="toc-text">promise？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js怎么实现链式调用？"><span class="toc-number">10.</span> <span class="toc-text">js怎么实现链式调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js怎么创建对象？"><span class="toc-number">11.</span> <span class="toc-text">js怎么创建对象？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工厂模式"><span class="toc-number">11.1.</span> <span class="toc-text">1.工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数模式"><span class="toc-number">11.2.</span> <span class="toc-text">2.构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-原型模式"><span class="toc-number">11.3.</span> <span class="toc-text">3.原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-组合使用构造函数模式和原型模式"><span class="toc-number">11.4.</span> <span class="toc-text">4.组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-动态原型模式"><span class="toc-number">11.5.</span> <span class="toc-text">5.动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生构造函数模式"><span class="toc-number">11.6.</span> <span class="toc-text">6.寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-稳妥构造函数模式"><span class="toc-number">11.7.</span> <span class="toc-text">7.稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从URL输入到页面显示经历了什么？"><span class="toc-number">12.</span> <span class="toc-text">从URL输入到页面显示经历了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#上面的步骤可以从哪些地方优化？"><span class="toc-number">13.</span> <span class="toc-text">上面的步骤可以从哪些地方优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-DNS解析"><span class="toc-number">13.0.1.</span> <span class="toc-text">1.DNS解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TCP连接"><span class="toc-number">13.0.2.</span> <span class="toc-text">2.TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-HTTP请求"><span class="toc-number">13.0.3.</span> <span class="toc-text">3.HTTP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-服务器处理请求，返回HTTP报文"><span class="toc-number">13.0.4.</span> <span class="toc-text">4.服务器处理请求，返回HTTP报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-浏览器解析渲染"><span class="toc-number">13.0.5.</span> <span class="toc-text">5.浏览器解析渲染</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP有什么了解？为什么是可靠的？"><span class="toc-number">14.</span> <span class="toc-text">TCP有什么了解？为什么是可靠的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#讲一下HTTP的头部"><span class="toc-number">15.</span> <span class="toc-text">讲一下HTTP的头部</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用标准请求头部"><span class="toc-number">15.0.1.</span> <span class="toc-text">常用标准请求头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用非标准请求头字段"><span class="toc-number">15.0.2.</span> <span class="toc-text">常用非标准请求头字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用标准响应头部"><span class="toc-number">15.0.3.</span> <span class="toc-text">常用标准响应头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用非标准请求头字段-1"><span class="toc-number">15.0.4.</span> <span class="toc-text">常用非标准请求头字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST和GET的区别"><span class="toc-number">16.</span> <span class="toc-text">POST和GET的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？"><span class="toc-number">17.</span> <span class="toc-text">深拷贝和浅拷贝？如何实现深拷贝？方法有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#搜索引擎优化？"><span class="toc-number">18.</span> <span class="toc-text">搜索引擎优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是语义化？语义化的好处？"><span class="toc-number">19.</span> <span class="toc-text">什么是语义化？语义化的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5的新特性？"><span class="toc-number">20.</span> <span class="toc-text">HTML5的新特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见web安全和防御？"><span class="toc-number">21.</span> <span class="toc-text">常见web安全和防御？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git和svn的区别？各自的应用场景？"><span class="toc-number">22.</span> <span class="toc-text">git和svn的区别？各自的应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写过微信小程序吗？为什么小程序的性能比较好？"><span class="toc-number">23.</span> <span class="toc-text">写过微信小程序吗？为什么小程序的性能比较好？</span></a></li>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&text=腾讯实习面试总结（二）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&is_video=false&description=腾讯实习面试总结（二）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=腾讯实习面试总结（二）&body=Check out this article: http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&title=腾讯实习面试总结（二）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2019/03/17/腾讯实习面试总结（二）/&name=腾讯实习面试总结（二）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Greensih
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/projects_url">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


